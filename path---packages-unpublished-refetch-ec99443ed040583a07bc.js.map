{"version":3,"sources":["webpack:///path---packages-unpublished-refetch-ec99443ed040583a07bc.js","webpack:///./.cache/json/packages-unpublished-refetch.json"],"names":["webpackJsonp","967","module","exports","data","package","id","updated","name","version","description","keywords","license","type","stars","readme","homepageUrl","repositoryUrl","npmUrl","issuesUrl","slug","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,SAAWC,GAAA,sBAAAC,QAAA,2BAAAC,KAAA,UAAAC,QAAA,QAAAC,YAAA,GAAAC,UAAA,gBAAAC,QAAA,MAAAC,KAAA,cAAAC,MAAA,EAAAC,OAAA,s4CAA6kDC,YAAA,KAAAC,cAAA,qCAAAC,OAAA,KAAAC,UAAA,KAAAC,KAAA,iCAAiKC,aAAgBf,GAAA","file":"path---packages-unpublished-refetch-ec99443ed040583a07bc.js","sourcesContent":["webpackJsonp([179423776689879],{\n\n/***/ 967:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"package\":{\"id\":\"unpublished/refetch\",\"updated\":\"2017-12-20T12:35:01.267Z\",\"name\":\"refetch\",\"version\":\"0.1.0\",\"description\":\"\",\"keywords\":[\"bucklescript\"],\"license\":\"MIT\",\"type\":\"unpublished\",\"stars\":8,\"readme\":\"<h1>refetch</h1>\\n<p>Refetch is a strongly typed and immutable API built on top of the <code>fetch</code> standard. It is also incomplete, highly experimental and prone to change.</p>\\n<h2>Example</h2>\\n<pre><code class=\\\"language-reason\\\">/* Simple GET */\\nResync.(Refetch.(\\n  get(\\\"http://httpbin.org/get\\\")\\n  |> Future.flatMap(\\n     fun | Response.Ok(_, response) => Response.text(response)\\n         | _ => \\\"oops!\\\" |> Future.from)\\n  |> Future.whenResolved(Js.log)\\n));\\n\\n/* builder functions */\\nResync.(Refetch.(\\n  request(`POST, \\\"https://httpbin.org/post\\\")\\n    |> Request.header(`ContentType(\\\"application/x-www-form-urlencoded; charset=UTF-8\\\"))\\n    |> Request.payload(`String(\\\"title=foobar&#x26;body=bar&#x26;userId=1\\\"))\\n  |> fetch\\n    |> Future.flatMap(\\n        fun | Response.Ok(_, response) => Response.text(response)\\n            | Response.Error({ reason }, _) => Future.from(reason))\\n    |> Future.whenResolved(Js.log)\\n));\\n\\n/* labeled arguments */\\nResync.(Refetch.(\\n  request(`POST, \\\"https://httpbin.org/post\\\",\\n    ~headers=[`ContentType(\\\"application/x-www-form-urlencoded; charset=UTF-8\\\")],\\n    ~body=`String(\\\"title=foobar&#x26;body=bar&#x26;userId=1\\\"))\\n  |> fetch\\n    |> Future.flatMap(\\n        fun | Response.Ok(_, response) => Response.text(response)\\n            | Response.Error({ reason }, _) => Future.from(reason))\\n    |> Future.whenResolved(Js.log)\\n));\\n</code></pre>\\n\",\"homepageUrl\":null,\"repositoryUrl\":\"https://github.com/glennsl/refetch\",\"npmUrl\":null,\"issuesUrl\":null,\"slug\":\"packages/unpublished/refetch\"}},\"pathContext\":{\"id\":\"unpublished/refetch\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---packages-unpublished-refetch-ec99443ed040583a07bc.js","module.exports = {\"data\":{\"package\":{\"id\":\"unpublished/refetch\",\"updated\":\"2017-12-20T12:35:01.267Z\",\"name\":\"refetch\",\"version\":\"0.1.0\",\"description\":\"\",\"keywords\":[\"bucklescript\"],\"license\":\"MIT\",\"type\":\"unpublished\",\"stars\":8,\"readme\":\"<h1>refetch</h1>\\n<p>Refetch is a strongly typed and immutable API built on top of the <code>fetch</code> standard. It is also incomplete, highly experimental and prone to change.</p>\\n<h2>Example</h2>\\n<pre><code class=\\\"language-reason\\\">/* Simple GET */\\nResync.(Refetch.(\\n  get(\\\"http://httpbin.org/get\\\")\\n  |> Future.flatMap(\\n     fun | Response.Ok(_, response) => Response.text(response)\\n         | _ => \\\"oops!\\\" |> Future.from)\\n  |> Future.whenResolved(Js.log)\\n));\\n\\n/* builder functions */\\nResync.(Refetch.(\\n  request(`POST, \\\"https://httpbin.org/post\\\")\\n    |> Request.header(`ContentType(\\\"application/x-www-form-urlencoded; charset=UTF-8\\\"))\\n    |> Request.payload(`String(\\\"title=foobar&#x26;body=bar&#x26;userId=1\\\"))\\n  |> fetch\\n    |> Future.flatMap(\\n        fun | Response.Ok(_, response) => Response.text(response)\\n            | Response.Error({ reason }, _) => Future.from(reason))\\n    |> Future.whenResolved(Js.log)\\n));\\n\\n/* labeled arguments */\\nResync.(Refetch.(\\n  request(`POST, \\\"https://httpbin.org/post\\\",\\n    ~headers=[`ContentType(\\\"application/x-www-form-urlencoded; charset=UTF-8\\\")],\\n    ~body=`String(\\\"title=foobar&#x26;body=bar&#x26;userId=1\\\"))\\n  |> fetch\\n    |> Future.flatMap(\\n        fun | Response.Ok(_, response) => Response.text(response)\\n            | Response.Error({ reason }, _) => Future.from(reason))\\n    |> Future.whenResolved(Js.log)\\n));\\n</code></pre>\\n\",\"homepageUrl\":null,\"repositoryUrl\":\"https://github.com/glennsl/refetch\",\"npmUrl\":null,\"issuesUrl\":null,\"slug\":\"packages/unpublished/refetch\"}},\"pathContext\":{\"id\":\"unpublished/refetch\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/packages-unpublished-refetch.json\n// module id = 967\n// module chunks = 179423776689879"],"sourceRoot":""}